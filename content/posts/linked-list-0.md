---
title: "學校不會教你的 C++ linked list 之 0"
date: 2019-03-17
tags: ["C++", "modern C++", "學校不會教的C++"]
---

給想寫作業而跑進來的小綿羊們
====

如果我的記憶沒有錯的話，我以前也 google 過如何實作 linked list 實作的文章，這八成是資工系萬古(如果那個時候還有人在寫程式)不變的題目吧

簡單來說，如果你只是想要這個晚上趕快吧作業寫完，好去夜衝或是玩遊戲的人，這系列文章並不是為你寫的，但是，嘿，我也喜歡玩遊戲

這只是一系列無聊冗長的介紹，因為你寫的東西是 C++，因為現在是 2019 年，所以你必須要習慣這點。或是你也可以加入 C++ 標準委員會的行列，幫助他們審查各種 paper，加速 C++ 的發展。啊，不過還是三年更新一次，等到那個時候，我希望你已經順利畢業了

廢話說完，讓我們進入正題吧


寫一個 linked list，這不是大學一年級的作業嗎？
====

是，但是有多少大學的作業，真的有好好的要求呢？

你的容器要如何讓其他開發者使用?

你的選擇怎樣的 build system？你如何打包你寫出來的套件？

你選用那一套測試框架？

你有寫測試嗎？你如何驗證程式的正確性？

你的容器要用怎樣的錯誤處理回報的？

你有仔細思考過如果設計容器的 API 嗎？

你有考慮過 ABI 相容問題嗎？

你的容器有是泛型容器嗎？還是該死的只能裝個 int?

你的容器要怎樣支援 C++ std algorithm 呢？

你的容器需要做類似 SSO (Small String Optimization) 的處理來加速嗎?

你有處理 rvalue reference 呼叫 method 時的特例嗎?

你的容器支援 copy 或是 move 嗎？如果有，他們都正確嗎？

最後，你設計出來的容器，使用上真的好用嗎？ 

前言
====

這一篇中，我們還不會開始撰寫程式碼，而是要先選定開發中會用到的工具跟選擇，他們分別為：

- 目標的作業系統
- 編譯器
- 採用何種 C++ 標準
- 套件管理系統 (package management)
- 版本控制系統 (version control system)
- 建制系統 (build system)
- 測試環境
- CI 環境
- 專案的 layout
- 友善的 IDE 支援

選擇目標的作業系統
----

你的函式庫想要給哪些作業系統使用？

這個部分會影響到可以選擇的編譯器，以及你可以使用的其他套件庫，假設他們不支援的你的目標作業系統的話，你自然就無法使用他們了

常見的作業系統目標不外乎是：`GNU/Linux`, `OSX` 跟 `Windows`

支援 `GNU/Linxu` 跟 `OSX` 是最常見的選項，誰知道，`Windows` 的事情總是特別麻煩

最簡單的選擇方式是，選則和你開發平臺相同的作業系統，如此一來你也好測試，遇到問題時也能更快處理

這系列文章的目標作業系統將僅選擇 **GNU/Linux x86_64** 作為範例

選擇編譯器
----

隨著所選的目標作業系統不同，你可以選的編譯器也會不一樣，可以使用的編譯器版本也會不一樣

編譯器版本主要的影響，應該就是錯誤訊息的呈現方式的，大致來說，越舊的編譯器，發生錯誤的訊息就越需要神祕學才得以解析，就連忘記加分號這件事，都需要一定的神祕學能力才得以正確理解並修復問題

所以過去學 C++ 學不好的同學不要氣餒，因為蠻有可能是你手上的工具一點忙都幫不上，還吐了一堆自以為是的訊息讓你無法理解而已。

這系列文章很偷懶，所以先以 **Clang++ 7.0.1** 作為基本的編譯器支援

選擇何種 C++ 標準
----

選擇不同的標準，會影響到能夠使用你套件的人數，以及你能夠使用的語言特性多寡

越新的標準，使用的人越少。你可能會說那幹嘛不升級，可惜現實是很殘酷的，升級上去你要怎麽保證既有的程式碼運作跟之前一樣呢？很多人沒寫測試，鬼才知道會不會出事情，所以乾脆別改，也有可能是真的很難測試，又或者是，我用的編譯器已經沒有在更新了，實在是慘慘慘

這裡的建議是至少選擇 C++ 11 或以上的標準，極多的編譯器已經完整支援 C++ 11 了，語言特性上，C++ 11 上也解決的許多問題，使用更舊的標準會讓其他人蠻困擾的

這系列文章將選用 **C++ 17**，因為這是範例程式專案，我才不管什麼誰要用呢

選擇套件管理系統 (package management system)
----

常見的套件管理系統有：

- 沒有套件管理系統
- hunter(cmake)
- vcpkg
- meson
- conan
- etc

你知道吧，因為十種標準實在是太混亂了，於是第十一種標準就出現了

即使過了二十年，C++ 在這塊依然是百家爭鳴的狀態，你就找一個看起來順眼的當作練習吧

這系列文章將選用 **meson build system**

因為我覺得很酷，你選你喜歡的就好了

選擇版本控制系統 (version control system)
----

你可以選擇 mercurial 而不是 git，然後不停抱怨他有多難用多慢多難找到教學文章或是相關資料

這系列文章將選用 **git**

不過其實你們也看不出來我用的是 git :P

選擇建制系統 (build system)
----

常見的選擇建制系統有：

- 沒有建制系統，每次都手動輸入編譯選項
- Makefile
- GNU autotools
- CMake
- Bazel
- Meson
- etc

可以到官方網站看看語法，喜歡就自己用。建制系統的重點在於，是否能夠良好的去處理套件模組化的概念，像 Makefile 就做的到，但是相對不容易維護，需要仰賴極度有自制力的開發者們(也就是很難的意思)

在 C++ 能夠做到如 node 那樣 `npm build` 或是 Rust 那樣 `cargo build` 之前，我覺得你怎麽選都差不多，因為在你用的很深之前，每個的缺陷其實不容易讓你遇到，除非他真的很難用

如何在建制系統處理編譯器版本，確認編譯器支援的功能等等話題真的是有點困難，後續應該是不會提到

這系列文章將選用 **meson**

因為我過去已經有一點 CMake 的使用經驗，所以想看看其他的東西用起來是怎樣(沒錯，我看過 CMake 可以寫的多可怕，簡直就是 CMake 語法的 Makefile)

選擇測試環境
----

測試很重要，但是學校不會教(笑

這簡直就像是醫生開刀以後，不知道怎麽幫病人複檢確認復原狀況一樣，可笑至極。我常常這樣說，因為不會出人命，所以大家都覺得可以等到出事再說啦，沒關係的

常見的 C++ 測試框架有：

- gtest
- catch1
- catch2

一樣可以去官網看看範例程式碼，選個喜歡的使用就好了。這個時候就能配合你剛剛選的套件管理系統使用，看要如何使用他把你選的測試套件加到專案裡面

這系列文章將選用 **catch2**

選擇 CI 環境
----

CI 是 Continuous Intergration 的縮寫，詳細定義請參考維基百科頁面

CI 的目的是讓你推送程式碼到 repository 時，能夠進行一連串的檢測，例如程式碼靜態分析，跑測試，生出報表等等。如果該筆修改有發現任何問題，就可以即時告知相關人員，及早做處理

重點在於，以上的流程必須是自動化的，如果需要人力介入，那就是讓事情變得不可靠的開始，道理是一樣的，你需要有一群自律性很高的員工，也就是很難的意思。況且人很容易懶的，又常常忘東忘西

選擇 CI 時要考慮，編譯執行的環境，因為這會直接影響到你可以使用的編譯器跟工具的版本，能夠直接跑 docker image 的 CI 環境相對來說會友善許多

我很久沒用 CI 系統了，就直接選用 **Cirrus CI**，簡單跟 github 做整合

決定專案的 layout
----

這是一個非常困難的問題，好在 C++ 多數的 build system 都有提供一定的彈性給你

這個範例專案中，因為要寫的是泛型的 linked list 套件，只會有 header file，因此整個專案的 layout 會是這個樣子的：

```
linked-list/
  - include/
    - linked-list/
      - ....hpp
  - tests/
    - main.cpp
    - ....cpp
```

一個 inlcude 資料夾，一個 tests 資料夾，其中 include 資料夾下的 linked-list 的資料夾，是為了在安裝時所留的，例如安裝到 `/usr/include` 時，他的目錄就會是 `/usr/include/linked-list` 這樣

友善的 IDE 支援
----

你的專案需要開發，開發需要環境，而你的專案是否能滿足多數人的開發環境？

使用一些現在的 build system 的話，通常都有辦法去生出各種的環境需要的資料，例如 ninja, makefile 等等。對於編譯的資訊，也可以生出 compile_database.json 之類的東西，方便工具 parse 程式碼，取得自動補完需要的資訊(去查查 libtool)

對於大型專案來說，這樣的環境可以讓開發者的心情更好，許多工具在使用上也會更方便，因為你有足夠的資料，就有辦法去做更多的事情，例如，快速修改變數名稱，或是全專案的變數命名檢查，等

沒有這些資訊？又來，你要仰賴一群自律的開發者，然後一堆事情無法自動化，恭喜！(eva 式拍手

選擇一個好的 build system 通常都可以幫你處理好這些事情，畢竟他們都可以幫你 build code，表示他們知道那些規則

最後
====

以我的選擇為例，在一切事物的準備好以後，你只需要這樣就能編譯你的專案了：

```shell
cd linked-list
meson build
cd build
ninja test && ninja install
```

當然，這只是大概，細節的部分，會在後續的章節提到的

下一章預計會來製作 linked list 中 Node 的部分

各種練習
====

- 裝好自己的開發環境
- 寫一個測試的 main，一個永遠失敗的測試案例，並且執行他讓他失敗
- 使用 debugger 進入到失敗的程式碼中，並且看得到 debug information
- 掛好 CI 並且讓他運作，然後在出錯時發送 email 給你
- 掛好 git hook 在 commit 前執行一次測試，或是所有的檢測
- 讓專案能夠給於使用者選擇編譯器的彈性
- 整合靜態分析工具到你的專案中 (cppcheck, clang static analyzer 等)
- 整合動態分析工具到你的專案中 (address sanitizer, valgrind 等)
- 上網看看別人的專案，是如何做這些事情了，他們選擇了那些工具，怎麽編譯程式碼的，在你的環境上，有怎樣的好處跟壞處(觀摩別人一向是有效的學習方式之一)






